# Отчет 69061057: https://contest.yandex.ru/contest/25597/run-report/69061057/
# Алгоритм работы
#   Используем динамическое программирование:
# 1. Заведем массив dp и будем хранить в нем в элементе i,j минимальное кол-во операций, необходимые,
#   необходимое для преобразования строки str_1[:i] в строку str_2[:j].
# 2. Базовый случай - первую строку и столбец заполняем числами от 0 до длины строки (т.е. сколько операций необходимо
#   для того, чтобы провести из/в пустую строку)
# 3. Для каждого элемента в массиве сравним символы в строках на соответствующих позициях и заполним массив dp нужными
#   значениями. Если символы одинаковы – берем значение из массива на предыдущей позиции на диагонале, если нет – берем
#   минимальное значение из левого, верхнего и диагонального (верхнего левого) элементов и добавляем 1.
# 4. Матрицу заполняем построчно, исключая первую строку и первый столбец, т.к. они уже заполнены в базовом случае.
# 5. Вернем значение из массива на последней позиции.
#
# Алгоритмическая сложность: O(n*m), где n - длина строки str_1, m - длина строки str_2.
# Сложность по памяти: O(m).
#
# Доказательство:
#   Очевидно, что количество изменений, необходимых для преобразования 2х пустых строк равно 0, для преобразования
# пустой строки в пустую – n удалений, для преобразования пустой строки в непустую – m вставок.
# Пусть у нас имеется матрица преобразований D(n,m), где n - длина первой строки, m - длина второй строки.
# Пусть первые k символов строк совпадают и матрица преоразований D(k,k) уже заполнена, тогда возможны 4 случая:
# 1. Строка str_1 имеет лишний символ на позиции i = k+1 'a', тогда, удаляя его из str_1, мы получим строку str_2 и
# для этого нам потребуется D(i,j) = D(k+1, k) = D(k,k) + 1 операций.
# 2. Аналогично вторая строка имеет на позиции j = k+1 'b', тогда добавляя его к str_1, мы получим строку str_2 и
# для этого нам потребуется D(i,j) = D(k, k+1) = D(k,k) + 1 операций.
# 3. Строки имееют одинаковый символ на позиции i = k+1 'с' и j = k+1 'с', тогда делать ничего не требуется, и кол-во
# операций, необходимое для преобразования строк не меняется D(i,j) = D(k+1, k+1) = D(k,k)
# 4. Строка str_1 имеет символ на позиции i = k+1 'a', str_2 на позиции j = k+1 'b', тогда заменяем один на
# другой, и кол-во операций будет D(i,j) = D(k+1, k+1) = D(k,k) + 1.
#   Соответсвенно, поскольку мы ищем минималное кол-во операций, мы можем начать с пустых строк, и далее, рассматривая
# приведение одной строки к другой, должны либо ничего не делать, когда встречаем одинаковые символы в строках, либо
# выбирать наиболее оптимальный предыдущий путь для преобразования строк и производить соотвествующую операцию.
#   Таким образом, посокльку на кажом шаге выбирался оптимальный путь преобразования, рассмотрев последовательно все
#   символы обеих строк, итоговое число операций будет находиться в D(n,m) и будет минимальным.


import sys
import unittest


def levenshtein_distance(first: str, second: str) -> int:
    n = len(first)
    m = len(second)
    dp = [[0] * (m + 1) for _ in range(2)]
    current, prev = 0, 1
    for j in range(1, m + 1):
        dp[current][j] = j
    for i in range(1, n + 1):
        prev, current = current, prev
        dp[current][0] = i
        for j in range(1, m + 1):
            if first[i - 1] == second[j - 1]:
                dp[current][j] = dp[prev][j - 1]
            else:
                dp[current][j] = min(dp[prev][j - 1], dp[prev][j], dp[current][j - 1]) + 1
    return dp[current][m]


if __name__ == '__main__':
    _first = sys.stdin.readline()
    _second = sys.stdin.readline()
    _res = levenshtein_distance(_first, _second)
    print(_res)


class Tests(unittest.TestCase):
    def test_first(self):
        first = 'abacaba'
        second = 'abaabc'
        expected = 2
        self.assertEqual(levenshtein_distance(first, second), expected)

    def test_second(self):
        first = 'innokentiy'
        second = 'innnokkentia'
        expected = 3
        self.assertEqual(levenshtein_distance(first, second), expected)

    def test_third(self):
        first = 'r'
        second = 'x'
        expected = 1
        self.assertEqual(levenshtein_distance(first, second), expected)
